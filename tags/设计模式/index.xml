<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 造舟野渡</title>
    <link>http://thoreauz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on 造舟野渡</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <copyright>All rights reserved - 2017</copyright>
    <lastBuildDate>Sat, 19 Jan 2019 11:40:16 +0000</lastBuildDate><atom:link href="http://thoreauz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RPC四-netty异步双向责任链</title>
      <link>http://thoreauz.com/2019/01/19/rpc4-netty-chain-of-responsibility-pattern/</link>
      <pubDate>Sat, 19 Jan 2019 11:40:16 +0000</pubDate>
      
      <guid>http://thoreauz.com/2019/01/19/rpc4-netty-chain-of-responsibility-pattern/</guid>
      <description>RPC系列 RPC一-线程模型 RPC二-NettyHandler处理消息 RPC三-rpc协议和编解码 RPC四-netty异步双向责任链 RPC五</description>
    </item>
    
    <item>
      <title>设计模式六：外观模式</title>
      <link>http://thoreauz.com/2017/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 08 Mar 2017 17:40:12 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 外观模式Facade是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。 外观模式的核心思想是通过创建一个外观类（Fac</description>
    </item>
    
    <item>
      <title>设计模式七：策略模式</title>
      <link>http://thoreauz.com/2017/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Mar 2017 13:42:22 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时动态地选择算法或行为，并将其封装在独立的策略对象中。策略模</description>
    </item>
    
    <item>
      <title>设计模式六：工厂模式</title>
      <link>http://thoreauz.com/2017/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 06 Mar 2017 17:40:12 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决什么问题 在某些情况下，创建对象可能涉及一系列复杂的初始化操作，例如查找配置文件、查询数据库表、初始化成员对象等。如果将这些逻辑放在构造函</description>
    </item>
    
    <item>
      <title>设计模式五：适配器</title>
      <link>http://thoreauz.com/2017/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%94%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Sun, 05 Mar 2017 12:25:53 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%94%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>适配器模式：将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类合作无间。是一种结构型设计模式。 先来看一个示例：我有一个手</description>
    </item>
    
    <item>
      <title>设计模式四：命令模式</title>
      <link>http://thoreauz.com/2017/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Mar 2017 10:57:59 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式是一种行为设计模式，将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。命令模式是一</description>
    </item>
    
    <item>
      <title>设计模式三：单例模式</title>
      <link>http://thoreauz.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2017 18:19:56 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 确保一个类只有一个实例，并提供一个全局访问点。单例很简单，最多就是需要考虑下多线程问题。 简单实现 public class Singleton { // static 记录唯一实例 private static Singleton uniqueInstance; // 私</description>
    </item>
    
    <item>
      <title>设计模式二：装饰者模式</title>
      <link>http://thoreauz.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2017 17:48:12 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式二：装饰者模式 本文摘自：《Head First 设计模式》 动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案。 这样说起来</description>
    </item>
    
    <item>
      <title>设计模式一：观察者模式</title>
      <link>http://thoreauz.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 01 Mar 2017 18:15:37 +0000</pubDate>
      
      <guid>http://thoreauz.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式 本文摘自：《Head First 设计模式》 观察者模式= 出版者+订阅者。定义了对象之间的一对多依赖，当一个对象改变状态时，所有依赖者都收到通知</description>
    </item>
    
  </channel>
</rss>
