<!DOCTYPE html>
<html lang="zh_CN">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="限流-阿里开源Sentinel"/>
<meta name="twitter:description" content=""/>
<meta name="twitter:site" content="@zhaozhou2010"/>



  	<meta property="og:title" content="限流-阿里开源Sentinel &middot; 造舟野渡" />
  	<meta property="og:site_name" content="造舟野渡" />
  	<meta property="og:url" content="http://thoreauz.com/2018/11/17/request-limit-Sentinel/" />

    
        
            <meta property="og:image" content="/images/cover.jpg"/>
        
    

    
    <meta property="og:description" content="" />
  	<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2018-11-17T13:48:16Z" />

    
    <meta property="article:tag" content="分布式系统" />
    
    

    <title>限流-阿里开源Sentinel &middot; 造舟野渡</title>

    
    <meta name="description" content="Sentinel作用 Sentinelm，分布式系统的流量防卫兵，可以从多个维度保护应用，广泛用于阿里各个系统，是大促稳定性保障的关键。现已开" />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://thoreauz.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://thoreauz.com/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="http://thoreauz.com/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="http://thoreauz.com/css/nav.css" />

    

    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atelier-forest-light.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
        
          
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/go.min.js"></script>
          
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/lua.min.js"></script>
          
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/vim.min.js"></script>
          
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/yaml.min.js"></script>
          
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/dockerfile.min.js"></script>
          
        
        <script>hljs.initHighlightingOnLoad();</script>
    

    
      
          <link href="http://thoreauz.com/index.xml" rel="alternate" type="application/rss+xml" title="造舟野渡" />
      
      
    
    <meta name="generator" content="Hugo 0.54.0" />

    <link rel="canonical" href="http://thoreauz.com/2018/11/17/request-limit-Sentinel/" />

    
      
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": ,
        "logo": http://thoreauz.comDog-b.svg
    },
    "author": {
        "@type": "Person",
        "name": ,
        
        "image": {
            "@type": "ImageObject",
            "url": http://thoreauz.comDog-b.svg,
            "width": 250,
            "height": 250
        }, 
        
        "url": http://thoreauz.com,
        "sameAs": [
            
            
             
             
             
             
             
            
        ]
    },
    "headline": 限流-阿里开源Sentinel,
    "name": 限流-阿里开源Sentinel,
    "wordCount": 4562,
    "timeRequired": "PT10M",
    "inLanguage": {
      "@type": "Language",
      "alternateName": en
    },
    "url": http://thoreauz.com/2018/11/17/request-limit-Sentinel/,
    "datePublished": 2018-11-17T13:48Z,
    "dateModified": 2018-11-17T13:48Z,
    
    "keywords": 分布式系统,
    "description": ,
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": http://thoreauz.com/2018/11/17/request-limit-Sentinel/
    }
}
    </script>
    


    

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-113511621-1', 'auto');
      ga('send', 'pageview');

    </script>
    

    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
            
            <li class="nav-opened" role="presentation">
            	<a href="http://thoreauz.com/archives/">归档</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="http://thoreauz.com/tags/">标签</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="http://thoreauz.com/about/">关于</a>
            </li>
        
        
    </ul>

    
    <a class="subscribe-button icon-feed" href="http://thoreauz.com/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">



<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
       <a class="blog-logo" href="http://thoreauz.com"><img src="http://thoreauz.com/Dog-b.svg" alt="Home" /></a>
      
  
  
      <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
  
  </nav>
</header>


<main class="content" role="main">


  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">限流-阿里开源Sentinel</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2018-11-17T13:48:16Z">
            2018-11-17
          </time>
        
         
          <span class="post-tag small"><a href="http://thoreauz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></span>
         
        </section>
    </header>

    <section class="post-content">
      

<h2 id="sentinel作用">Sentinel作用</h2>

<p>Sentinelm，分布式系统的流量防卫兵，可以从多个维度保护应用，广泛用于阿里各个系统，是大促稳定性保障的关键。现已开源，github地址<a href="https://github.com/alibaba/Sentinel">Sentinel</a>。</p>

<p>最常用的场景就是限流，比方说提供某个http接口的服务，经过压测，我单机qps只能达到500，流量再大就可能导致系统崩溃，从而无法提供服务。参考压测进过，可以对此接口限流500，一旦超过，其他请求就快速失败，从而保证系统正常工作不被压垮。sentinel总结起来主要有以下作用：<br />
1. 保护服务提供方不被过于频繁的调用压垮。<br />
2. 保护服务调用方不被不可用的服务拖死。<br />
3. 保护系统不超过负载。</p>

<p>Sentinel 的开源生态：<br />
<img src="https://user-images.githubusercontent.com/9434884/46240214-9c72ff80-c3d6-11e8-937a-0cffa1e8dc58.png" alt="" /><br />
&gt; 图1: 来源：sentinel github wiki</p>

<!-- more -->

<h2 id="qps限流示例">qps限流示例</h2>

<p>下文通过一个示例，见<a href="https://github.com/alibaba/Sentinel">github</a>下sentinel-demo/sentinel-demo-basic。其他如spring的整合见spring-cloud-starter-alibaba-sentinel<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md">文档</a></p>

<pre><code class="language-java">static class RunTask implements Runnable {
    @Override
    public void run() {
        while (!stop) {
            Entry entry = null;

            try {
                // 1.获取token，如果不能，将会抛出BlockException
                entry = SphU.entry(KEY);
                pass.addAndGet(1);
            } catch (BlockException e1) {
                block.incrementAndGet();
            } catch (Exception e2) {
                // biz exception
            } finally {
                total.incrementAndGet();
                if (entry != null) {
                    // 2. 退出
                    entry.exit();
                }
            }
            Random random2 = new Random();
            try {
                TimeUnit.MILLISECONDS.sleep(random2.nextInt(50));
            } catch (InterruptedException e) {
            }
        }
    }
}
</code></pre>

<p>上面只是截取了FlowQpsDemo的一段代码，这个示例主要做了几个工作：<br />
1. 初始化限流规则,限流20<br />
2. 开启32个线程循环执行RunTask，并把总qps/通过qps/限流qps分表计入3个AtomicInteger<br />
3. 开启一个定时任务，每秒统计一次3个AtomicInteger的值，作为统计数据输出</p>

<p>如:</p>

<pre><code>1541907654105, total:1185, pass:20, block:1165
46 send qps is: 1218
1541907655110, total:1218, pass:21, block:1197
45 send qps is: 1130
1541907656115, total:1130, pass:20, block:1110
44 send qps is: 1177
1541907657119, total:1177, pass:22, block:1155
</code></pre>

<blockquote>
<p>出现大于20的情况，因为统计线程有误差。那么，sentinel之所以能限流，肯定也统计了qps，有误差么？这个问题以后讨论</p>
</blockquote>

<h2 id="概念名词解释">概念名词解释</h2>

<p><img src="http://thoreauz.com/images/2018-11-13-17-20-08.jpg" alt="" /><br />
&gt; 图2</p>

<p>可以理解，上图为一个应用，其中ABCDEF为可以对其授权、限流、降级的入口，在sentinel中也叫<strong>切入点</strong>。比如现在访问C的qps为100，但是有可能A-&gt;C的访问频繁但不是很重要，而B-C次数不多但比较关键。此时我只想对A-&gt;C限流，于是就需要一个链路的概念，途中1、2、3组成3条<strong>链路</strong>，链路上的切入点也叫<strong>树节点</strong>。这些切入点可能处于不同链路如C，于是把用来汇总切入点信息的叫<strong>簇结点</strong>。</p>

<p>示最简单的示例中，sentinel入口代码，定义一个切入口。</p>

<pre><code class="language-java">// 为需要保护的资源(概念或者逻辑上)定义一个入口，所有访问资源的请求都需要从此入口申请令牌
Entry entry = SphU.entry(“自定义资源名”);
</code></pre>

<p>如果要把节点纳入链路中，需要根据链路限流，需要通过上下文（Context）声明链路入口如：</p>

<pre><code class="language-java">ContextUtil.enter(&quot;entrance1&quot;, &quot;appA&quot;);
Entry nodeA = SphU.entry(&quot;nodeA&quot;);
if (nodeA != null) {
nodeA.exit();
}
 ContextUtil.exit();
</code></pre>

<h2 id="原理">原理</h2>

<p>还是从示例FlowQpsDemo，进入<code>entry = SphU.entry(KEY)</code>代码开始分析；</p>

<pre><code class="language-java">// 为了获取令牌，从此入口进入，通过一些列ProcessorSlot校验限流规则，能通过返回Entry，否则抛BlockException
public Entry entry(ResourceWrapper resourceWrapper, int count, Object... args) throws BlockException {
    Context context = ContextUtil.getContext();
    if (context instanceof NullContext) {
         return new CtEntry(resourceWrapper, null, context);
    }
    if (context == null) {
        // Using default context.
        context = MyContextUtil.myEnter(Constants.CONTEXT_DEFAULT_NAME, &quot;&quot;, resourceWrapper.getType());
    }
    // 2
    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);

    /*
     * Means amount of resources (slot chain) exceeds {@link Constants.MAX_SLOT_CHAIN_SIZE},
     * so no rule checking will be done.
     */
    if (chain == null) {
        return new CtEntry(resourceWrapper, null, context);
    }

    Entry e = new CtEntry(resourceWrapper, chain, context);
    try {
        chain.entry(context, resourceWrapper, null, count, args);
    } catch (BlockException e1) {
        e.exit(count, args);
        throw e1;
    } catch (Throwable e1) {
        // This should not happen, unless there are errors existing in Sentinel internal.
        RecordLog.info(&quot;Sentinel unexpected exception&quot;, e1);
    }
    return e;
}
</code></pre>

<ol>
<li>从threadLocal获取Context，没有就使用默认Context<br /></li>
<li>获取处理Slot(ProcessorSlot)<br /></li>
<li>执行Slot的entry方法，校验通过则返回Entry<br />
<br /></li>
</ol>

<p>整个设计模式和netty类似：</p>

<p>|责任链模式|netty |sentinel|<br />
|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|<br />
|链|ChannelPipeline | chain |<br />
|处理器|ChannelHandler| ProcessorSlot  |<br />
|上下文,携带元数据|ChannelHandlerContext|Context   |<br />
|不同|双向链表|单向链表|</p>

<p>所以下文重点看采用了哪些ProcessorSlot。</p>

<h3 id="processorslot">ProcessorSlot</h3>

<p>先看lookProcessChain是如何创建ProcessorSlotChain。</p>

<pre><code class="language-java">ProcessorSlot&lt;Object&gt; lookProcessChain(ResourceWrapper resourceWrapper) {
    // 更加资源wrapper从缓存查询
    ProcessorSlotChain chain = chainMap.get(resourceWrapper);
    if (chain == null) {
        // 缓存不存在，加锁双重检查创建chain
        synchronized (LOCK) { 
            chain = chainMap.get(resourceWrapper);
            if (chain == null) {
                if (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) {
                    return null;
                }
                chain = SlotChainProvider.newSlotChain();
                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = new HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(
                    chainMap.size() + 1);
                newMap.putAll(chainMap);
                newMap.put(resourceWrapper, chain);
                chainMap = newMap;
            }
        }
    }
    return chain;
}
</code></pre>

<p>我们接着看<code>chain = SlotChainProvider.newSlotChain()</code>如何创建chain，跟踪代码发现DefaultSlotChainBuilder这个类，build方法如下。</p>

<pre><code class="language-java"> public ProcessorSlotChain build() {
    ProcessorSlotChain chain = new DefaultProcessorSlotChain();
    chain.addLast(new NodeSelectorSlot());
    chain.addLast(new ClusterBuilderSlot());
    chain.addLast(new LogSlot());
    chain.addLast(new StatisticSlot());
    chain.addLast(new SystemSlot());
    chain.addLast(new AuthoritySlot());
    chain.addLast(new FlowSlot());
    chain.addLast(new DegradeSlot());
    return chain;
}
</code></pre>

<ul>
<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；<br /></li>
<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；<br /></li>
<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；<br /></li>
<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；<br /></li>
<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；<br /></li>
<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；<br /></li>
<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；<br />
<br /></li>
</ul>

<p>总体框架图：<br />
<img src="https://github.com/alibaba/Sentinel/raw/master/doc/image/slots.gif" alt="" /><br />
&gt; 图3</p>

<p><img src="https://user-images.githubusercontent.com/9434884/46783631-93324d00-cd5d-11e8-8ad1-a802bcc8f9c9.png" alt="" /><br />
&gt;图4: 3/4来源：sentinel github wiki</p>

<p>下午详细看看几个slot。</p>

<h3 id="nodeselectorslot">NodeSelectorSlot</h3>

<p>从上文可知，NodeSelectorSlot对象是根据resourceWrapper缓存，也就是说，图2中BC节点(资源/入口)分别拥有不同NodeSelectorSlot对象。NodeSelectorSlot缓存了对应节点DefaultNode。</p>

<p>但是，缓存DefaultNode的key不是资源名，因为同一个资源可能处于不同链路，所以，sentinel采用Context的名字来缓存DefaultNode，从而构建不同链路的节点树；</p>

<p>图3中treenode还有一种结构没有画出来：</p>

<pre><code> *                  machine-root
 *                  /         \
 *                 /           \
 *         EntranceNode1   EntranceNode2
 *               /               \
 *              /                 \
 *      DefaultNode(nodeA)   DefaultNode(nodeA)
 *             |                    |
 *             +- - - - - - - - - - +- - - - - - -&gt; ClusterNode(nodeA);
</code></pre>

<blockquote>
<p>图5</p>
</blockquote>

<h3 id="clusterbuilderslot">ClusterBuilderSlot</h3>

<p>ClusterBuilderSlot用来创建构建资源的ClusterNode，主要维护资源的运行时统计数据，比如响应时间、qps、线程数、异常等。一个资源有一个clusterNode，但可以有多个defaultNode，如上图5。</p>

<h3 id="statisticslot">StatisticSlot</h3>

<p>StatisticSlot 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据，维护到NodeSelectorSlot和ClusterBuilderSlot创建的数据结构中：<br />
* clusterNode：资源唯一标识的 ClusterNode 的 runtime 统计<br />
* origin：根据来自不同调用者的统计信息<br />
* defaultnode: 根据上下文条目名称和资源 ID 的 runtime 统计<br />
* 入口的统计</p>

<p>核心代码：</p>

<pre><code class="language-java">@Override
public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, Object... args)
    throws Throwable {
    try {
        fireEntry(context, resourceWrapper, node, count, args);
        // 线程+1
        node.increaseThreadNum();
        // 通过请求数+1
        node.addPassRequest();

        if (context.getCurEntry().getOriginNode() != null) {
            // 如果origin不为空，也更新数据
            context.getCurEntry().getOriginNode().increaseThreadNum();
            context.getCurEntry().getOriginNode().addPassRequest();
        }

        if (resourceWrapper.getType() == EntryType.IN) {
            // ru入站请求，全局统计
            Constants.ENTRY_NODE.increaseThreadNum();
            Constants.ENTRY_NODE.addPassRequest();
        }
        
        for (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) {
            handler.onPass(context, resourceWrapper, node, count, args);
        }
    } catch (BlockException e) {
        context.getCurEntry().setError(e);

        // Add block count.
        node.increaseBlockQps();
        if (context.getCurEntry().getOriginNode() != null) {
            context.getCurEntry().getOriginNode().increaseBlockQps();
        }

        if (resourceWrapper.getType() == EntryType.IN) {
            Constants.ENTRY_NODE.increaseBlockQps();
        }

        for (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) {
            handler.onBlocked(e, context, resourceWrapper, node, count, args);
        }

        throw e;
    } catch (Throwable e) {
        context.getCurEntry().setError(e);

        // Should not happen
        node.increaseExceptionQps();
        if (context.getCurEntry().getOriginNode() != null) {
            context.getCurEntry().getOriginNode().increaseExceptionQps();
        }

        if (resourceWrapper.getType() == EntryType.IN) {
            Constants.ENTRY_NODE.increaseExceptionQps();
        }
        throw e;
    }
}
</code></pre>

<p>我们关注下这两行代码：</p>

<pre><code class="language-java">node.increaseThreadNum();
node.addPassRequest();
</code></pre>

<p>线程数统计比较容器，AtomicInteger保存即可。但是qps怎么统计，毕竟qps是一段时间内的请求数量。<br />
我们找到如下代码：</p>

<pre><code class="language-java">@Override
public void addPassRequest() {
    rollingCounterInSecond.addPass();
    rollingCounterInMinute.addPass();
}
</code></pre>

<p>在深入看代码之前，我们先看看，假设统计qps，我们会怎么做。比如用一个AtomicInteger数组保存每一秒的请求，index就是当前秒/60。 统计qps只需要用当前时间计算数组Index，就可以获取qps。比如下图，1时秒10qps,2秒时400qps。<br />
<img src="http://thoreauz.com/images/2018-11-16-20-10-36.jpg" alt="" /><br />
&gt;图6</p>

<p>问题在于：读取qps的时间不是整秒，比如上图，统计时刻2秒500毫秒，此时，获取的qps是100，但其实还有后500毫秒的请求没有统计。如果此时我统计t-1呢，也就是1秒的qps，此刻qps是准确的，但是不及时，第2秒的qps突然暴增，那统计就延迟了一秒。对只用来展示倒是问题不太大，但是对于限流来说，晚1秒可能系统已经挂了。</p>

<p>优化的办法，我们会想，把时间间隔缩小，比如10ms。这样是更准确了，但是就得保存很多数据，并且求qps需要把100个刻度加起来。对资源消耗太大。下面，我们看看sentinel怎么做的。</p>

<p>sentinel使用滑动窗口，数据结构如下：<br />
<img src="http://thoreauz.com/images/2018-11-16-21-10-34.jpg" alt="" /><br />
&gt; 图7</p>

<pre><code class="language-java">public class WindowWrap&lt;T&gt; {
    /**
     * 一个bucket的长度，单位毫秒
     */
    private final long windowLengthInMs;
    /**
     * 窗口开始时间，也是毫秒
     */
    private long windowStart;
    /**
     * 统计值
     */
    private T value;
 }
</code></pre>

<p>sentinel 默认采用windowLengthInMs=500计算qps。也就是说，1秒只有两个窗口。初始化如下方式如下</p>

<pre><code class="language-java">// 1. 创建rollingCounterInSecond
private transient volatile Metric rollingCounterInSecond = new ArrayMetric(1000 / SampleCountProperty.SAMPLE_COUNT,1）
ArrayMetric{
    // 2. ArrayMetric包装了 MetricsLeapArray
     private final MetricsLeapArray data = new MetricsLeapArray(500, 1);
}
public abstract class LeapArray&lt;T&gt; {
    // 3 array 所以计算qps  ，sampleCount = 2。
    protected final AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array = new AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt;(sampleCount);
}
</code></pre>

<p>创建几个bucket，取决于SampleCountProperty.SAMPLE_COUNT设置。还有个rollingCounterInMinute用于存储分钟请求数，buckets长度是1000ms。</p>

<h4 id="累积请求">累积请求</h4>

<p>主要是以下步骤：<br />
1. 获取当前窗口(bucket)<br />
2. bucket的值+1</p>

<p>获取当前窗口(bucket)<br />
1. 获取当前时间<br />
2. 计算当前时间对应的bucket下标(index)和bucket起始时间。<br />
3. 获取窗口 array.get(index),</p>

<pre><code class="language-java">public WindowWrap&lt;T&gt; currentWindow(long time) {
    long timeId = time / windowLengthInMs;
    // Calculate current index.
    int idx = (int)(timeId % array.length());

    // Cut the time to current window start.
    time = time - time % windowLengthInMs;

    while (true) {
        WindowWrap&lt;T&gt; old = array.get(idx);
        if (old == null) {
            WindowWrap&lt;T&gt; window = new WindowWrap&lt;T&gt;(windowLengthInMs, time, newEmptyBucket());
            if (array.compareAndSet(idx, null, window)) {
                return window;
            } else {
                Thread.yield();
            }
        } else if (time == old.windowStart()) {
            return old;
        } else if (time &gt; old.windowStart()) {
            if (updateLock.tryLock()) {
                try {
                    // if (old is deprecated) then [LOCK] resetTo currentTime.
                    return resetWindowTo(old, time);
                } finally {
                    updateLock.unlock();
                }
            } else {
                Thread.yield();
            }

        } else if (time &lt; old.windowStart()) {
            // Cannot go through here.
            return new WindowWrap&lt;T&gt;(windowLengthInMs, time, newEmptyBucket());
        }
    }
}
</code></pre>

<pre><code>1. 如果为空就新创建一个，new WindowWrap&lt;T&gt;
2. 如果不为空，且窗口时间对得上，则使用这个窗口
3. 如果时间大于返回窗口的起始时间，说明这个窗口过期，应该加锁重置为新窗口
4. 如果窗口时间小于返回窗口的起始时间，也不能用，也需要新返回一个bucket
</code></pre>

<pre><code class="language-java">// add pass(LongAdder)
wrap.value().addPass();

MetricBucket{
      // 使用LongAdder保存数据，高并发下比cas原子操作类性能更好
      private final LongAdder pass = new LongAdder();
}
</code></pre>

<h4 id="获取qps">获取qps</h4>

<p>qps就是通过的请求，统计pass只需要把所有bucket的请求相加，StatisticNode代码如下：</p>

<pre><code class="language-java">@Override
public long pass() {
    data.currentWindow();
    long pass = 0;
    List&lt;MetricBucket&gt; list = data.values();

    for (MetricBucket window : list) {
        pass += window.pass();
    }
    return pass;
}
</code></pre>

<blockquote>
<p>qps统计只用了两个buckets，其实也跟我们最初设计的有一样的问题，如果流量波动加大，还是反应慢，可以适当调整bucket数量，比如10个。</p>
</blockquote>

<h3 id="systemslot">SystemSlot</h3>

<p>按系统负载级别限流。只按照一个切入口qps，可能并不能反映系统负责情况。还可能需要考虑所有线程、qps、rt，load等。</p>

<pre><code class="language-java">@Override
public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, Object... args)
    throws Throwable {
    SystemRuleManager.checkSystem(resourceWrapper);
    fireEntry(context, resourceWrapper, node, count, args);
}
</code></pre>

<pre><code class="language-java">public static void checkSystem(ResourceWrapper resourceWrapper) throws BlockException {
    // Ensure the checking switch is on.
    if (!checkSystemStatus.get()) {
        return;
    }
    // for inbound traffic only
    if (resourceWrapper.getType() != EntryType.IN) {
        return;
    }
    // total qps
    double currentQps = Constants.ENTRY_NODE == null ? 0.0 : Constants.ENTRY_NODE.successQps();
    if (currentQps &gt; qps) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;qps&quot;);
    }
    // total thread
    int currentThread = Constants.ENTRY_NODE == null ? 0 : Constants.ENTRY_NODE.curThreadNum();
    if (currentThread &gt; maxThread) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;thread&quot;);
    }
    double rt = Constants.ENTRY_NODE == null ? 0 : Constants.ENTRY_NODE.avgRt();
    if (rt &gt; maxRt) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;rt&quot;);
    }
    // BBR algorithm.
    if (highestSystemLoadIsSet &amp;&amp; getCurrentSystemAvgLoad() &gt; highestSystemLoad) {
        if (currentThread &gt; 1 &amp;&amp;
            currentThread &gt; Constants.ENTRY_NODE.maxSuccessQps() * Constants.ENTRY_NODE.minRt() / 1000) {
            throw new SystemBlockException(resourceWrapper.getName(), &quot;load&quot;);
        }
    }
}
</code></pre>

<p>比较好理解，只是多了一个load的实时统计。这里使用一个算法<code>BBR</code> 来实现。</p>

<h2 id="总结">总结</h2>

<p>本文简单介绍sentinel的责任链模式完成限流，并介绍了几个slot。其实还有很多细节可以挖掘。</p>

<hr />

<p>参考:<br />
1. <a href="https://github.com/alibaba/Sentinel/wiki/">https://github.com/alibaba/Sentinel/wiki/</a><br />
2. <a href="https://github.com/sentinel-group/sentinel-awesome">https://github.com/sentinel-group/sentinel-awesome</a></p>

    </section>
    <section class="post-toc">
      <span>CONTENTS</span>
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#sentinel作用">Sentinel作用</a></li>
<li><a href="#qps限流示例">qps限流示例</a></li>
<li><a href="#概念名词解释">概念名词解释</a></li>
<li><a href="#原理">原理</a>
<ul>
<li><a href="#processorslot">ProcessorSlot</a></li>
<li><a href="#nodeselectorslot">NodeSelectorSlot</a></li>
<li><a href="#clusterbuilderslot">ClusterBuilderSlot</a></li>
<li><a href="#statisticslot">StatisticSlot</a>
<ul>
<li><a href="#累积请求">累积请求</a></li>
<li><a href="#获取qps">获取qps</a></li>
</ul></li>
<li><a href="#systemslot">SystemSlot</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
    </section>


  <footer class="post-footer">

    








<figure class="author-image">
    <a class="img" href="http://thoreauz.com" style="background-image: url(/Dog-b.svg)"><span class="hidden">二道涯's Picture</span></a>
</figure>


<section class="author">
  <h4><a href="http://thoreauz.com">二道涯</a></h4>
  
  <p>Read <a href="http://thoreauz.com">more posts</a> by this author.</p>
  
  <div class="author-meta">
    <span class="author-location icon-location">Hangzhou, China</span>
    <span class="author-link icon-link"><a href="http://thoreauz.com">http://thoreauz.com</a></span>
  </div>
</section>




    
<section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" style="font-size: 1.4em"
       href="https://twitter.com/share?text=%e9%99%90%e6%b5%81-%e9%98%bf%e9%87%8c%e5%bc%80%e6%ba%90Sentinel&nbsp;-&nbsp;%e9%80%a0%e8%88%9f%e9%87%8e%e6%b8%a1&amp;url=http%3a%2f%2fthoreauz.com%2f2018%2f11%2f17%2frequest-limit-Sentinel%2f"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" style="font-size: 1.4em"
       href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fthoreauz.com%2f2018%2f11%2f17%2frequest-limit-Sentinel%2f"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-pinterest" style="font-size: 1.4em"
       href="http://pinterest.com/pin/create/button/?url=http%3a%2f%2fthoreauz.com%2f2018%2f11%2f17%2frequest-limit-Sentinel%2f&amp;description=%e9%99%90%e6%b5%81-%e9%98%bf%e9%87%8c%e5%bc%80%e6%ba%90Sentinel"
       onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
        <span class="hidden">Pinterest</span>
    </a>
    <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=http%3a%2f%2fthoreauz.com%2f2018%2f11%2f17%2frequest-limit-Sentinel%2f"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>



    
     
        
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: "2b2dad16b1a3987d6f94",
    clientSecret: "1c9113ee087febd62068f33f47c190fc4e38bf48",
    repo: "gitment-comments",
    owner: "ThoreauZZ",
    admin: ["ThoreauZZ"],
    
    id: md5(location.pathname),
    distractionFreeMode: "true"
  });
  gitalk.render("gitalk-container");
</script>

 
    



  </footer>
</article>

</main>


  <aside class="read-next">
  
      <a class="read-next-story" style="no-cover" href="http://thoreauz.com/2018/11/17/request-limit-Sentinel-use/">
          <section class="post">
              <h2>限流-Sentinel使用</h2>
              
          </section>
      </a>
  
  
      <a class="read-next-story prev" style="no-cover" href="http://thoreauz.com/2018/11/04/mac-install-minikube/">
          <section class="post">
              <h2>在mac上安装minikube</h2>
          </section>
      </a>
  
</aside>


    <footer class="site-footer clearfix">
        
        <div class="bsz-counter">
            <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次;</span>
            <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span>
        </div>
        

        <section class="copyright"><a href="">造舟野渡</a> All rights reserved - 2017</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        

    </footer>

    </div>
    <script type="text/javascript" src="http://thoreauz.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://thoreauz.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://thoreauz.com/js/index.js"></script>
    
</body>
</html>

